> - 原文地址：[What is Server-Side Request Forgery (SSRF)?](https://www.acunetix.com/blog/articles/server-side-request-forgery-vulnerability/)
> - 原文作者：[Ian Muscat](https://www.acunetix.com/blog/author/ianmuscat/)
> - 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)
> - 本文永久链接：[https://github.com/xitu/gold-miner/blob/master/article/2021/server-side-request-forgery-vulnerability.md](https://github.com/xitu/gold-miner/blob/master/article/2021/server-side-request-forgery-vulnerability.md)
> - 译者：
> - 校对者：

# What is Server-Side Request Forgery (SSRF)?

# 什么是服务端请求伪造（SSRF）？

![](https://www.acunetix.com/wp-content/uploads/2019/02/ssrf_banner-910x273.png)

Server-side request forgery (SSRF) vulnerabilities let an attacker send crafted requests from the back-end server of a vulnerable web application. Criminals usually use SSRF attacks to target internal systems that are behind firewalls and are not accessible from the external network. An attacker may also leverage SSRF to access services available through the loopback interface (127.0.0.1) of the exploited server.

服务端请求伪造（SSRF）漏洞让攻击者从存在漏洞的应用程序的后端服务器中发送恶意请求。攻击者通常使用 SSRF 攻击位于防火墙之后的内部系统，这些内部系统是不能从外部网络访问的。攻击者也可以利用 SSRF 访问通过服务器的环回接口可访问的服务。

SSRF vulnerabilities occur when an attacker has full or partial control of the request sent by the web application. A common example is when an attacker can control the third-party service URL to which the web application makes a request.

当攻击者可以完全控制或部分控制应用程序发送的请求时，SSRF 漏洞就出现了。常见的例子是攻击者能控制第三方服务的 URL，并且应用程序将发起该 URL 对应的请求。

The following is an example in PHP that is vulnerable to server-side request forgery (SSRF).

以下是一个 PHP 例子，它易遭受 SSRF 攻击。

```php
<?php

/**
* Check if the 'url' GET variable is set
* 检查是否设置了 GET 变量 'url'
* Example - http://localhost/?url=http://testphp.vulnweb.com/images/logo.gif
* 例如 - http://localhost/?url=http://testphp.vulnweb.com/images/logo.gif
*/
if (isset($_GET['url'])){
$url = $_GET['url'];

/**
* Send a request vulnerable to SSRF since
* no validation is being done on $url
* before sending the request
*/
/**
* 发起易遭受 SSRF 攻击的请求因为
* 在发起请求之前
* 没有对 $url 做验证
*/
$image = fopen($url, 'rb');

/**
* Send the correct response headers
*/
/**
* 发送正确的响应头
*/
header("Content-Type: image/png");

/**
* Dump the contents of the image
*/
/**
* 响应图片的内容
*/
fpassthru($image);}
```

In the above example, the attacker has full control of the **url** parameter. They can make arbitrary GET requests to any website on the Internet and to resources on the server (**localhost**).

在上面的例子中，攻击者可以完全控制 **url** 参数。他们可以向因特网上的任意网站和被攻击服务器（**localhost**）上的资源发起 GET 请求。

In the following example, an attacker makes a request to Apache HTTP servers with **mod_status** enabled (enabled by default).

在下面的例子中，攻击者向 Apache HTTP 服务发起一个请求。该 Apache HTTP 服务开启了 **mode_status** 模式（该模式默认是开启的）。

```
GET /?url=http://localhost/server-status HTTP/1.1
Host: example.com
```

Attackers can also use SSRF to make requests to other internal resources that the web server has access to, which are not publicly available. For example, they can access cloud service instance metadata like AWS/[Amazon EC2](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) and [OpenStack](https://docs.openstack.org/admin-guide/compute-networking-nova.html). An attacker can even get creative with SSRF and [run port scans on internal IPs.](https://www.acunetix.com/blog/articles/ssrf-vulnerability-used-to-scan-the-web-servers-network/)

攻击者也可以使用 SSRF 向其他内部资源发起请求。这些内部资源可以被应用程序的服务器访问，但它们不是公开可访问的。例如，攻击者可以访问类似 AWS/[Amazon EC2](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) 和 [OpenStack](https://docs.openstack.org/admin-guide/compute-networking-nova.html) 的云服务实例的元数据。攻击者甚至可以利用 SSRF 发挥创意，[对内部 IP 进行端口扫描](https://www.acunetix.com/blog/articles/ssrf-vulnerability-used-to-scan-the-web-servers-network/)。

```
GET /?url=http://169.254.169.254/latest/meta-data/ HTTP/1.1
Host: example.com
```

Apart from the **http://** and **https://** URL schemas, an attacker may take advantage of lesser-known or legacy URL schemas to access files on the local system or on the internal network.

除了 **http://** 和 **https://** URL 协议之外，攻击者可以利用鲜为人知的或古老的 URL 协议访问本地系统或内部网路上的文件。

The following example uses the **file:///** URL schema.

下面的例子使用了 **file:///** 洗衣。

```
GET /?url=file:///etc/passwd HTTP/1.1
Host: example.com
```

Some applications may enable attackers to use more exotic URL schemas. For example, if the application uses cURL to make requests, the attacker can use the **dict://** URL schema to make requests to any host on any port and send custom data.

部分应用可能允许攻击者使用更多奇怪的 URL 协议。比如，如果应用使用 cURL 发起请求，那么攻击者可以使用 **dict://** URL 协议向任意的主机和端口发起请求，并发送自定义数据。

```
GET /?url=dict://localhost:11211/stat HTTP/1.1
Host: example.com
```

The above request will cause the application to connect to **localhost** on port 11211 and send the string `stat`. Port 11211 is the default port used by [Memcached](https://memcached.org/), which is not normally exposed.

上面的请求使得应用程序连接 **localhost** 的 11211 端口，并发送 `stat` 字符串。端口 11211 是 [Memcached](https://memcached.org/) 的默认端口，该端口通常不会对外暴露。

## Detecting Server-Side Request Forgery

## 检查服务端请求伪造

To automatically detect server-side request forgery, you need to rely on an intermediary service. Detection of such vulnerabilities requires an out-of-band and time-delay vector. Acunetix solves this by using [AcuMonitor](https://www.acunetix.com/vulnerability-scanner/acumonitor-technology/) as the intermediary service.

为了自动检测服务端请求伪造，你需要使用一个中间服务，因为检查这种漏洞需要一种外部可访问并存在时延的方式。Acunetix 通过将 [AcuMonitor](https://www.acunetix.com/vulnerability-scanner/acumonitor-technology/) 作为中间服务解决该问题。

During a scan, Acunetix makes requests that contain a unique AcuMonitor URL. If AcuMonitor receives a request on one of these unique URLs, it sends a notification back to Acunetix. It causes Acunetix to raise an alert for SSRF.

在扫描期间，Acunetix 向不同的 AcuMonitor URL 发起请求。如果 AcuMonitor 在这个不同的 URL 中收到一个请求，它将通知 Acunetix。这使得 Acunetix 发出 SSRF 警报。

The following is a result of an Acunetix scan with AcuMonitor, which detected a server-side request forgery. The alert contains information about the HTTP request. It includes the IP address of the server that made the request and the `User-Agent` string used in the request (if any). This information can help developers identify the source of the problem and fix it.

下图是使用 AcuMonitor 的 Acunetix 扫描结果，它检查了服务端请求伪造。该警报包含 HTTP 请求的信息。它包括发起请求的服务器 IP 地址和请求中携带的 `User-Agent` 字符串（如果存在）。这些信息可以帮助开发者定位问题源头并修复问题。

![](https://www.acunetix.com/wp-content/uploads/2019/02/ssrf_screenshot-910x673.png)

## Mitigating Server-Side Request Forgery

## 消除服务端请求伪造

Simple blacklists and regular expressions applied to user input are a bad approach to mitigating SSRF. In general, blacklists are a poor means of security control. Attackers will always find methods to bypass them. In this case, an attacker can use an HTTP redirect, a wildcard DNS service such as **xip.io**, or even [alternate IP encoding](http://www.pc-help.org/obscure.htm).

在用户输入中应用简单的黑名单和正则表达式是消除 SSRF 攻击的糟糕方法。通常，黑名单是一种几乎无效的安全控制手段。攻击者总是可以找到方法去绕过它们。在这个例子中，攻击者可以使用 HTTP 重定向、通配符 DNS 服务（比如 **xip.io**）或者甚至是 [可替代的 IP 编码](http://www.pc-help.org/obscure.htm)。

### Whitelists and DNS Resolution

### 白名单和 DNS 解析

The most robust way to avoid server-side request forgery (SSRF) is to whitelist the DNS name or IP address that your application needs to access. If a whitelist approach does not suit you and you must rely on a blacklist, it’s important to validate user input properly. For example, do not allow requests to private (non-routable) IP addresses (detailed in [RFC 1918](https://tools.ietf.org/html/rfc1918)).

最鲁棒的避免服务端请求伪造的方式是给你的应用需要访问的 DNS 名称和 IP 地址添加到白名单中。如果白名单机制不能满足你的需求，并且你必须依赖黑名单机制，那么对用户输入进行合理的校验就显得非常重要。比如，不允许向私有的 IP 地址发起请求（私用 IP 地址参考 [RFC 1918](https://tools.ietf.org/html/rfc1918)）。

However, in the case of a blacklist, the correct mitigation to adopt will vary from application to application. In other words, there is no universal fix to SSRF because it highly depends on application functionality and business requirements.

然而，在使用黑名单的场景中，正确的消除 SSRF 的方式将因应用而异。换句话说，目前还没有使用黑名单机制修复 SSRF 漏洞的银弹，因为它高度依赖应用功能和业务需求。

### Response Handling

### 处理响应

To prevent response data from leaking to the attacker, you must ensure that the received response is as expected. Under no circumstances should the raw response body from the request sent by the server be delivered to the client.

### Disable Unused URL Schemas

### 禁用不使用的 URL 协议

If your application only uses HTTP or HTTPS to make requests, allow only these URL schemas. If you disable unused URL schemas, the attacker will be unable to use the web application to make requests using potentially dangerous schemas such as **file:///**, **dict://**, **ftp://**, and **gopher://**.

### Authentication on Internal Services

### 内网服务进行身份认证

By default, services such as Memcached, Redis, Elasticsearch, and MongoDB do not require authentication. An attacker can use server-side request forgery vulnerabilities to access some of these services without any authentication. Therefore, to ensure web application security, it’s best to enable authentication wherever possible, even for services on the local network.

> 如果发现译文存在错误或其他需要改进的地方，欢迎到 [掘金翻译计划](https://github.com/xitu/gold-miner) 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 **本文永久链接** 即为本文在 GitHub 上的 MarkDown 链接。

---

> [掘金翻译计划](https://github.com/xitu/gold-miner) 是一个翻译优质互联网技术文章的社区，文章来源为 [掘金](https://juejin.im) 上的英文分享文章。内容覆盖 [Android](https://github.com/xitu/gold-miner#android)、[iOS](https://github.com/xitu/gold-miner#ios)、[前端](https://github.com/xitu/gold-miner#前端)、[后端](https://github.com/xitu/gold-miner#后端)、[区块链](https://github.com/xitu/gold-miner#区块链)、[产品](https://github.com/xitu/gold-miner#产品)、[设计](https://github.com/xitu/gold-miner#设计)、[人工智能](https://github.com/xitu/gold-miner#人工智能)等领域，想要查看更多优质译文请持续关注 [掘金翻译计划](https://github.com/xitu/gold-miner)、[官方微博](http://weibo.com/juejinfanyi)、[知乎专栏](https://zhuanlan.zhihu.com/juejinfanyi)。
